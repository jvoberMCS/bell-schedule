import { useMainStore } from '@/stores/MainStore'
import { massillonOrange } from '@/theme/colors/colors'
import React, { useEffect, useRef } from 'react'

type Props = { width: number; height: number }
type CountdownTimerProps =
	Props extends Record<string, never>
		? React.FC<Record<string, never>>
		: React.FC<Props>

const getCurrentTime = () => {
	const now = new Date()
	return now
}

export const CountdownTimer: CountdownTimerProps = ({ width, height }) => {
	const scheduleSelection = useMainStore((state) => state.scheduleSelection)
	const schedules = useMainStore((state) => state.schedules)
	const canvasRef = useRef<HTMLCanvasElement | null>(null)

	const getTimeDifference = (t1: Date, t2: Date) => {
		// Get the difference in milliseconds
		const diffInMilliseconds = t2.getTime() - t1.getTime()

		// Calculate the difference in hours, minutes, and seconds
		const diffInSeconds = Math.abs(Math.round(diffInMilliseconds / 1000))
		const hours = Math.floor(diffInSeconds / 3600)
		const minutes = Math.floor((diffInSeconds % 3600) / 60)
		const seconds = diffInSeconds % 60
		return {
			hours: hours,
			minutes: minutes,
			seconds: seconds,
			negative: diffInMilliseconds < 0 ? true : false,
		}
	}

	const setFutureDate = (today: Date, numDaysInFuture: number) => {
		if (numDaysInFuture <= 0)
			throw new Error(
				'Number of day in the future must be greater than 0'
			)
		return new Date(today.setDate(today.getDate() + numDaysInFuture))
	}

	const getNextBell = (schedule: Schedule) => {
		const currentTime = getCurrentTime().getTime()
		const mod2End = schedule.periods[5].end
		//return new Date(mod1End - currentTime)
		return [mod2End, currentTime]
	}

	useEffect(() => {
		const canvas = canvasRef.current
		if (canvas) {
			const w = canvas.width
			const h = canvas.height
			const ctx = canvas.getContext('2d')

			if (!ctx) return // Check to make sure context isnt null

			let animationFrameId: number

			const animate = () => {
				ctx.clearRect(0, 0, width, height) // Clear the canvas

				// Get the current time
				const currentTime = getCurrentTime()
				ctx.font = '20px Fira Code'
				ctx.fillStyle = massillonOrange

				// Current Time
				ctx.fillText(
					currentTime.toLocaleTimeString(),
					w * 0.5 -
						ctx.measureText(currentTime.toLocaleTimeString())
							.width /
							2,
					h * 0.2
				)

				// Get the difference in time
				const endOfDay = new Date()
				endOfDay.setHours(14)
				endOfDay.setMinutes(20)
				endOfDay.setSeconds(0)
				const timeUntilEndOfDay = getTimeDifference(
					currentTime,
					endOfDay
				)

				// Time until end of the mod
				const nextBell = getNextBell(
					schedules.filter(
						(schedule) => schedule.selectionID === scheduleSelection
					)[0]
				)

				ctx.fillText(
					`${nextBell[0]}  ${nextBell[1]}`,
					w * 0.5 -
						ctx.measureText(`${nextBell[0]}, ${nextBell[1]}`)
							.width /
							2,
					h * 0.3
				)
				ctx.fillText(
					`${nextBell[0] > nextBell[1] ? '>' : '<'}`,
					w * 0.5 - ctx.measureText(`<`).width / 2,
					h * 0.3
				)

				// ctx.fillText(
				// 	`Next Bell: ${nextBell.getHours()} hours : ${nextBell.getMinutes()} minutes : ${nextBell.getSeconds()} seconds`,
				// 	w * 0.5 -
				// 		ctx.measureText(
				// 			`Next Bell: ${nextBell.getHours()} hours : ${nextBell.getMinutes()} minutes : ${nextBell.getSeconds()} seconds`
				// 		).width /
				// 			2,
				// 	h * 0.4
				// )

				// Time until the end of the day
				ctx.fillText(
					`${timeUntilEndOfDay.negative === true ? '-' : ''}${timeUntilEndOfDay.hours < 10 ? '0' : ''}${timeUntilEndOfDay.hours}:${timeUntilEndOfDay.minutes < 10 ? '0' : ''}${timeUntilEndOfDay.minutes}:${timeUntilEndOfDay.seconds < 10 ? '0' : ''}${timeUntilEndOfDay.seconds} until the end of the day`,
					w * 0.5 -
						ctx.measureText(
							`${timeUntilEndOfDay.negative === true ? '-' : ''}${timeUntilEndOfDay.hours < 10 ? '0' : ''}${timeUntilEndOfDay.hours}:${timeUntilEndOfDay.minutes < 10 ? '0' : ''}${timeUntilEndOfDay.minutes}:${timeUntilEndOfDay.seconds < 10 ? '0' : ''}${timeUntilEndOfDay.seconds} until the end of the day`
						).width /
							2,
					h * 0.8
				)

				animationFrameId = requestAnimationFrame(animate)
			}

			animate()
			return () => cancelAnimationFrame(animationFrameId) // Cleanup
		} else {
			console.error('Canvas is null')
			return
		}
	}, [])
	return <canvas ref={canvasRef} width={width} height={height} />
}
